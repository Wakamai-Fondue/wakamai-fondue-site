<template>
	<section class="features" id="features">
		<h2 class="section-title">Layout Features</h2>

		<div class="content" v-if="hasRequiredFeatures">
			<h3>Required layout features</h3>
			<p>
				These are always turned on by the system that renders the font.
				You can’t turn them off — in fact, you're not supposed to!
				Required layout features may be applicable only to certain
				language scripts or specific languages, or in certain writing
				modes.
			</p>
			<ul class="required-features">
				<li
					v-for="feature in requiredFeatures"
					:key="`reqfeat_${feature.tag}`"
				>
					<span class="opentype-label">{{ feature.tag }}</span>
					{{ feature.uiName || feature.name }}
				</li>
			</ul>
		</div>
		<div class="content" v-if="hasOptionalFeatures">
			<h3>Optional layout features</h3>
			<p>
				Some are turned on by default, but can be turned off. Others are
				turned off by default, but can be turned on.
			</p>

			<div
				v-for="feature in optionalFeatures"
				:key="`optfeat_${feature.tag}`"
				class="feature-demo"
			>
				<div class="feature-control" :id="`feature-${feature.tag}`">
					<span class="opentype-label">{{ feature.tag }}</span>
					{{ feature.uiName || feature.name }}
					<span
						class="state"
						:class="feature.state === 'on' ? 'on' : 'off'"
					>
						<strong v-if="feature.state === 'on'">On</strong>
						<strong v-else>Off</strong>
						by default
					</span>
					<label class="flip-state">
						<input
							type="checkbox"
							@change="flipState(feature.tag)"
							:disabled="!featureChars[feature.tag]"
							checked
						/><span>Show</span>
					</label>
				</div>

				<template v-if="isValidFeature(feature)">
					<template
						v-for="(lookup, index) in featureChars[feature.tag][
							'lookups'
						]"
					>
						<span
							v-if="lookup['type'] === 3"
							:style="getFeatureStyle(feature.tag)"
							:data-type="lookup['typeName']"
							:key="`lookup_3_${feature.tag}_${index}`"
							class="chars"
							contenteditable="plaintext-only"
							spellcheck="false"
							autocorrect="off"
						>
							<template v-for="(char, index) in lookup['input']">
								<span
									v-for="n in lookup['alternateCount'][index]"
									:key="`type3_${char}_${n}`"
									:style="getFeatureStyle(feature.tag, n)"
								>
									{{ char }}
								</span>
							</template>
						</span>

						<template v-else-if="lookup['type'] === 6"></template>

						<span
							v-else
							:style="getFeatureStyle(feature.tag)"
							:data-type="lookup['typeName']"
							:key="`lookup_6_${feature.tag}_${index}`"
							class="chars"
							contenteditable="plaintext-only"
							spellcheck="false"
							autocorrect="off"
						>
							{{ lookup["input"].join(" ") }}
						</span>
					</template>

					<template
						v-if="
							featureChars[feature.tag]['summary'][
								'uniqueCombinations'
							].length
						"
					>
						<span
							:style="getFeatureStyle(feature.tag)"
							:key="`combsummary_${feature.tag}_{index}`"
							data-summary="Randomly generated sample of possible combinations"
							class="chars summarized"
							contenteditable="plaintext-only"
							spellcheck="false"
							autocorrect="off"
						>
							{{ getCombinations(feature) }}
						</span>
					</template>

					<div
						v-if="featureChars[feature.tag]['summary']['isCapped']"
						class="feature-message"
					>
						There are
						{{
							featureChars[feature.tag]["summary"][
								"totalCombinations"
							]
						}}
						substitutions for this feature, only showing the first
						1000.
					</div>

					<div class="code">
						<CopyToClipboard
							:content="getFeatureCSS(feature.tag)"
						/>
						<Prism language="css" :key="`code_${feature.tag}`">{{
							getFeatureCSS(feature.tag)
						}}</Prism>
					</div>
				</template>
				<div
					v-else
					class="feature-message"
					:style="getFeatureStyle(feature.tag)"
				>
					This feature only modifies glyphs generated by other
					features.
				</div>
			</div>
		</div>
	</section>
</template>

<script>
import Prism from "vue-prism-component";
import CopyToClipboard from "@/components/CopyToClipboard.vue";

export default {
	props: ["font"],
	components: {
		Prism,
		CopyToClipboard,
	},
	data() {
		return {
			currentStates: [],
			hasOptionalFeatures:
				this.font.features.filter((f) => f.state !== "fixed").length >
				0,
			hasRequiredFeatures:
				this.font.features.filter((f) => f.state === "fixed").length >
				0,
			featureChars: this.getFeatureChars(),
		};
	},
	computed: {
		optionalFeatures() {
			return this.font.features.filter((f) => f.state !== "fixed");
		},
		requiredFeatures() {
			return this.font.features.filter((f) => f.state === "fixed");
		},
	},
	methods: {
		getFeatureChars() {
			// Try to return the "best" layout features
			if (
				"DFLT" in this.font.featureChars &&
				"dflt" in this.font.featureChars["DFLT"]
			) {
				return this.font.featureChars["DFLT"]["dflt"];
			} else if (
				"latn" in this.font.featureChars &&
				"dflt" in this.font.featureChars["latn"]
			) {
				return this.font.featureChars["latn"]["dflt"];
			} else if (Object.keys(this.font.featureChars).length > 0) {
				// If all else fails, return first
				const first = Object.keys(this.font.featureChars)[0];
				return Object.values(this.font.featureChars[first])[0];
			} else {
				return {};
			}
		},
		flipState(feature) {
			this.currentStates[feature] = 1 - this.currentStates[feature];
		},
		isValidFeature(feature) {
			return (
				this.featureChars[feature.tag] &&
				this.featureChars[feature.tag]["lookups"].length &&
				this.featureChars[feature.tag]["lookups"][0]["input"].length
			);
		},
		// Use onState for features that take a specific number
		// instead of just 0 or 1.
		getFeatureStyle(feature, onState = 1) {
			const offState = 0;
			let state;
			if (this.currentStates[feature] !== undefined) {
				// CSS state exists, use it
				state = this.currentStates[feature];
			} else {
				// No CSS state yet, create one based off default state
				this.currentStates[feature] = 1;
				state = 1;
			}
			return `font-feature-settings:"${feature}" ${
				state ? onState : offState
			};`;
		},
		getFeatureCSS(feature) {
			// Type 3 lookups are non-boolean, deal with those if we got 'em
			if (
				this.featureChars[feature] &&
				this.featureChars[feature]["lookups"]
			) {
				const type3Lookup = this.featureChars[feature]["lookups"].find(
					(lookup) => lookup.type === 3
				);

				if (type3Lookup) {
					const maxAlternates = this.getMaxAlternates(type3Lookup);
					if (maxAlternates > 1) {
						return `font-feature-settings: "${feature}" 1; /* Use value 1 to ${maxAlternates} for all alternates */`;
					}
				}
			}

			return `font-feature-settings: "${feature}";`;
		},
		getCombinations(feature) {
			if (feature.tag === "frac") {
				const uniqueCombinations =
					this.featureChars[feature.tag]["summary"][
						"uniqueCombinations"
					];

				const allChars = new Set();
				uniqueCombinations.forEach((combo) => {
					[...combo].forEach((char) => allChars.add(char));
				});

				// Check if font supports digits and slashes
				const hasDigits = [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9",
				].some((d) => allChars.has(d));
				const hasSlash = allChars.has("/") || allChars.has("⁄");

				if (hasDigits && hasSlash) {
					// Show human readable pre-made examples if supported...
					return "1/1 1/2 1/3 1/4 1/5 1/6 1/7 1/8 1/9 2/3 4/5 6/7 8/9 10/10";
				} else {
					// ...else, show actual combinations
					return uniqueCombinations.join(" ");
				}
			} else {
				return this.featureChars[feature.tag]["summary"][
					"uniqueCombinations"
				].join(" ");
			}
		},
		getMaxAlternates(lookup) {
			if (!lookup.alternateCount || lookup.alternateCount.length === 0) {
				return 0;
			}
			return Math.max(...lookup.alternateCount);
		},
	},
};
</script>

<style scoped>
.features p {
	margin: 1rem 0;
}

.features .content + .content {
	margin-top: 4rem;
}

.required-features li {
	margin-bottom: var(--small-margin);
}

.feature-demo + .feature-demo {
	margin-top: 2rem;
}

.state {
	margin-left: auto;
	margin-right: 0.5em;
	color: var(--yellow);
}

.state.on {
	color: var(--green);
}

.flip-state [disabled] + span {
	color: var(--unlighterer-grey);
}

.required-features li,
.feature-control {
	display: flex;
	align-items: center;
}

.chars {
	display: block;
	position: relative;
	font-family: var(--font-stack);
	font-size: var(--preview-font-size, 1.5rem);
	background: var(--light-grey);
	padding: 0.5rem;
	margin-top: var(--small-margin);
	overflow: hidden;
}

.feature-message {
	font-feature-settings: normal !important;
	font-family: var(--system-font-stack);
	font-style: italic;
	color: var(--unlighterer-grey);
	background: var(--light-grey);
	padding: 0.5rem;
	margin-top: var(--small-margin);
	overflow: hidden;
}

.code {
	position: relative;
}
</style>
